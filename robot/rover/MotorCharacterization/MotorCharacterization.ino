/*
    This code outputs a motor's step response in rpm on a Teensy 3.6.
    Each interrupt generated by the motor's encoder corresponds to a certain
    angle rotated by the motor shaft, and by measuring how long it has been
    since the previous interrupt, the motor's speed can be calculated with
    the angle difference divided by the time difference.

    Please note that the encoder is located on the motor's input shaft,
    so the speeds measured refer to the input speed of the motor, rather
    than the output speed, which is what is seen after the motor shaft
    has gone through the gear reduction.

    The angle difference is calculated in degrees and the time difference
    is calculated in microseconds. The motor turns for an amount of time defined
    beforehand, each interrupt placing the time differences in the dt[] array.
    After the motor has stopped turning, the motor's speed is calculated. The
    calculation is done afterwards because floating point math takes time and
    interrupt service routines should occur very quickly.

    Josh Glazer, November 3 2018
*/

#define DIR_PIN        5
#define PWM_PIN        6
#define ENCODER_A      7
#define ENCODER_B      8
#define PULSES_PER_REV 7
#define ARRAY_SIZE     1000
#define RUN_TIME       1000

unsigned int startTime;
volatile unsigned int interruptCount = 0;
volatile unsigned int prevTime = micros();

volatile unsigned int dt[ARRAY_SIZE];
float omega[ARRAY_SIZE];

float angularResolution = 360 / PULSES_PER_REV; // for only one channel
//float angularResolution = 360 / (PULSES_PER_REV*2); // for both channels

void encoder_ISR(void);

void setup() {
  Serial.begin(115200); Serial.setTimeout(50);
  Serial.println("Starting");

  // initialize the pins
  pinMode(PWM_PIN, OUTPUT);
  pinMode(DIR_PIN, OUTPUT); // for new driver
  pinMode(ENCODER_A, INPUT_PULLUP);
  pinMode(ENCODER_B, INPUT_PULLUP);
  attachInterrupt(ENCODER_A, encoder_ISR, CHANGE);
  //attachInterrupt(ENCODER_B, encoder_ISR, CHANGE);

  // start the motor
  digitalWrite(DIR_PIN, 0);
  analogWrite(PWM_PIN, 256);

  unsigned int startTime = millis();
}

void loop() {
  unsigned int currTime = millis();
  if ( (currTime - startTime) > RUN_TIME ) {
    // 2 seconds are up, so the motor has probably stabilized
    analogWrite(PWM_PIN, 0);

    int i = 1;
    while (i < ARRAY_SIZE) {
      float degPerMicros = angularResolution / dt[i];
      float degPerSec = degPerMicros * 1000000;
      omega[i] = 60 * degPerSec / 360; // in rpm
      // print rpm and dt (microseconds)
      Serial.print(omega[i], 7); Serial.print(","); Serial.println(dt[i], 7);
      delay(100);
      i++;
    }
  }
}

/*
    This interrupt service routine is called on every changing edge of an encoder pin.
    It determines how long it's been (in microseconds) since the previous interrupt.
    It puts this value in the dt[] array to be used afterwards, which is used later
    to calculate the speed because the calculation involves floating point math.
    Floating point math takes time to calculate and should not be done in an ISR.
*/
void encoder_ISR(void) {
  interruptCount++;
  dt[interruptCount] = micros() - prevTime;
  prevTime = micros();
}

