stepper angle check needs to occur each software interrupt or every few interrupts because if the movement messes up in the middle we need a check... could do this in main loop actually

for now do steppers with constant period, worry about the ramping up and down later because probably requires individual timer interrupts

what do I do for angles over 360? do i keep counting up? do i keep count of how many rotations I've done?

need step angle resolution and factor based on microstepping, though in our code there's no microstepping

check recommended pid time interval period

servo: estimate calculation based on speed and time

make sure all variables affected by interrupts are volatile

for steppers the check is more to do with whether the amount of steps has been reached and if not, try to step more

whereas for dc they control voltage so the issue there is whether the pid tries to go to max voltage

what happens if a new command tells the motor to turn in opposite direction? abrupt changes are bad. if the stepper is trying to turn but hasn't gotten anywhere there should be a check in the microcontroller that there's an issue (there can also be a check in the gui)

for encoder interrupt testing set up the arduino with op amp? something? - voltage divider - teensy, send 3.3v to all interrupt pins simultaneously to test thing?

having the motor activate and deactivate things all over the place is probably inevitable

floating point math doesn't seem bad, but at worst, convert float to int before motor control and do int math inside interrupts

we don't want to miss messages, we need to know if messages were missed, for example know starting and ending message characters, we need some kind of confirmation anyway

quadrature on ftm1,2: pins 3/4,29/30: cant use for pwm anymore
quadrature on tpm1,2: pins 16/17, (tpm2 not implemented in teensy?)

initialization function should maybe sweep to both ends of the arm's range? or maybe just do this when the arm design is finalized and init function only goes one direction

don't worry about 3.3v because the driver probably compares the 3.3pwm with the 3.3vcc

option to disable pid?

fuzzy logic followed by pid? just fuzzy logic? different pid constants based on how large the error is? small-medium error has large constants and medium high has smaller ones so it doesn't overreact?

according to my googling, many people say that for steppers it's better to control them open-loop style until the very end of the motion, at which point you correct for errors based on the angle difference. This is partly because of the step angle resolution compared to the encoder resolution and pid output resolution causing instability since the PID tries to overcompensate too quickly?

But since we have a gear/belt reduction, and since we can programmatically decide which errors we can ignore, maybe it's not as big of a deal and PID is okay... after all, we'd have to manually implement stepper acceleration if we don't use a PID, although code examples do already exist.