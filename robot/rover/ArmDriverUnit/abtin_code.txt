
/*
  unsigned int c0 = 1600;  // was 2000 * sqrt( 2 * angle / accel )

  struct stepperInfo {
  void (*dirFunc)(int);
  void (*stepFunc)();
  volatile float dir = 0;
  volatile float currentAngle = 0;
  volatile float desiredAngle = 0;
  volatile bool movementDone = true;
  };

  struct dcInfo {
  volatile int dir = 127; // 0 to 255 where 127 is the midpoint and stops the motor
  volatile float currentAngle = 0;
  volatile float desiredAngle = 0;
  volatile bool dcMovementDone = false;
  volatile long encCount = 0;
  };

  struct servoInfo {
  volatile int dir = 127; // 0 to 255 where 127 is the midpoint and stops the motor
  volatile float currentAngle = 0;
  volatile float desiredAngle = 0;
  volatile bool dcMovementDone = false;
  volatile long encCount = 0;
  };

  volatile stepperInfo steppers[NUM_STEPPERS];
  char serialBuffer[BUFFER_SIZE];
  volatile dcInfo dcMotor;
  bool led_status = true;
  int startTime = 0;

  void M1Step() {
  M1_STEP_HIGH
  M1_STEP_LOW
  }
  void M1Dir(int d) {
  digitalWrite(M1_DIR_PIN, d);
  }

  void M2Step() {
  M2_STEP_HIGH
  M2_STEP_LOW
  }
  void M2Dir(int d) {
  digitalWrite(M2_DIR_PIN, d);
  }
*/




 setup(){
  /*
  steppers[0].dirFunc  = M1Dir;
  steppers[0].stepFunc = M1Step;

   steppers[1].dirFunc  = M2Dir;
  steppers[1].stepFunc = M2Step;

   noInterrupts();
  TCCR1A = 0;
  TCCR1B = 0;
  TCNT1  = 0;
  OCR1A = 1000;
  TCCR1B |= (1 << WGM12);
  TCCR1B |= ((1 << CS11) | (1 << CS10));
  interrupts();

   //start of the heartbeat timer
  startTime = millis();
  */
}

 loop(){

   /* //dcMotor.currentAngle = abs(dcMotor.encCount) / 5.555;
  if (!dcMotor.dcMovementDone) {
    //    Serial.print(dcMotor.encCount); Serial.print(","); Serial.println(dcMotor.currentAngle);
    analogWrite(DC_PWM_PIN, dcMotor.dir);
  }

   //  if (abs(dcMotor.currentAngle - dcMotor.desiredAngle) < 0.5 ) {
  //    analogWrite(DC_PWM_PIN, 127);
  //    dcMotor.dcMovementDone = true;
  //  }
*/
  /* //heartbeat : blink LED every 1 second
  int t2 = millis();
  if ( (t2 - startTime) > 1000) {
    startTime = t2;
    led_status = !led_status;
  }
  */


 }



 /* void ISR(TIMER1_COMPA_vect)
{
  for (int i = 0; i < NUM_STEPPERS; i++) {
    volatile stepperInfo& s = steppers[i];

     if (s.currentAngle >= 360) {
      s.currentAngle = 0;
    }
    if (s.currentAngle < 0) {
      s.currentAngle = 360;
    }

     if ( abs(s.currentAngle - s.desiredAngle) > 1.7 && !s.movementDone  ) {
      s.stepFunc();
      s.currentAngle += s.dir;

     } else {
      s.movementDone = true;
    }

     if (steppers[0].movementDone && steppers[1].movementDone) {  //very dirty. we dont want to check manually.
      TIMER1_INTERRUPTS_OFF
    }
  }
}
*/
/* void prepareMovement(int stepperNumber, float angle) {

   volatile stepperInfo& s = steppers[stepperNumber];

   s.desiredAngle = angle;
  s.movementDone = false;

   if (s.currentAngle < s.desiredAngle) {
    if (abs(s.currentAngle - s.desiredAngle) < 180) {
      s.dir = +1.8;
      s.dirFunc(1);
    } else {
      s.dir = -1.8;
      s.dirFunc(0);
    }
  } else {
    if (abs(s.currentAngle - s.desiredAngle) < 180) {
      s.dir = -1.8;
      s.dirFunc(0);
    } else {
      s.dir = +1.8;
      s.dirFunc(1);
    }
  }
}
*/
/* void startMovement() {
  OCR1A = c0;
  TIMER1_INTERRUPTS_ON
}
*/


 /* void prepareDCMotor(float angle) {

   dcMotor.desiredAngle = angle;
  dcMotor.dcMovementDone = false;

   if (dcMotor.currentAngle < dcMotor.desiredAngle) {
    if (abs(dcMotor.currentAngle - dcMotor.desiredAngle) < 180) {
      dcMotor.dir = 100;
    } else {
      dcMotor.dir = 150;
    }
  } else {
    if (abs(dcMotor.currentAngle - dcMotor.desiredAngle) < 180) {
      dcMotor.dir = 150;
    } else {
      dcMotor.dir = 100;
    }
  }
}
*/

